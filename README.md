# quineforge
A theoretical system with strong ability to turing-complete-challenge-response between peers or parts of a software within a single computer, to converge toward high data integrity in a turing-complete way and various processes related to turing-complete things that many people and computers might build together and navigate the space of possible lambda functions (within quines for more redundant cross reference between them).

This system can have an exact representation of pi, e, the cube root of 49999, and other "real numbers" and data structures of finite kolmogorov-complexity and infinite size, a function of integer to bit, since each one of the binary digits of pi is a specific digit number and takes a finite time to compute it, so any function which computes pi can be used as a pi.

A quine is a software which outputs its own source code. Quineforge is a very experimental data format for the lossless compression of quines and for translating all possible non-quines (such as pictures of cats, videos, games, GPU matrix multiply algorithms, or nearly anything) into quine form. It uses the https://en.wikipedia.org/wiki/Chain_rule_for_Kolmogorov_complexity and a 5-way gametree (like a chess or go gametree), specificly move turing tape (of lambda function contents) left 1, move it right 1, copy from register to center of tape, copy from center of tape to register, or call whats in register on whats in center of tape and replace register with that (which can derive all possible lambda functions), to navigate the space of all possible lambda functions. Its security level is planned to be, eventually after the bugs are worked out, enough for the operation of industrial machines and low lag enough to satisfy hardcore gamers. TODO I should copy some of the "fntape" (5 way tree) theory from occamsfuncer readme and various parts of kolmogorov theory. Basically, for example, if we are using sha3_256 (with some pre and post processing of a merkle forest node (or its faster lazy merkle form), then at some few points in a sequence of bits will occur those 256 bits, and the 256 bit ids of other functions, sparsely, and between those are 1 bit at a time opcodes (or 3 or 4 bit opcodes, or something like that), with some opcodes being to say that what follows is a variable size number of 1 bits followed by a 0 bit, then a powOf2 number of bits is a complete binary tree of bits (cbt) which is a lambda function of Lx.Ly.Lz.zxy aka the church encoding of the pair function whose "leafs" are Lx.Ly.x (true) and Lx.L.y.y (false), which goes into the "register" of "fntape" which is basically a lambda datastruct of 2 linkedlists with 5 possible actions from each possible state: move turingtape left (whose cell contents are each a function), move it right, copy register to center of tape, copy center of tape to register, or (heres the only turing complete part) call register on whats at center of turing tape and replace register with what that returns (and using various statistical methods if there is an infinite loop or other nonhalting lambda call it will be given up on quickly before that happens, within some approx specified low lag limits, but compressed forms are expected not to have nonhalters or overly expensive operations etc else they are not shared in the network as often as cheaper faster more useful data structures). So basically theres a bunch of functions, in the space of all possible lambda functions sparsely explored among many computers and people (some of which may be cat memes, minigames, compressed random bitstrings, or whatever) and fntape kind of opcodes aka small bitstrings from one id256 to another id256 such as to say its left child (a few bits of fntape) or its right child etc, or various combinator on eachother, leads to what else. Its a space where, as the name quineforge implies, the distance of bitstring from any function, or from any small set of functions, to any other function, has bigO that is certainly within the distance predicted by kolmogorov complexity theory and which in practice may be able to compete with zip files, 7z files, wavelet sound compression, neuralnet video compression, AIXI compression, andOr any other imaginable kind of compression, and trading compression efficiency for low lag and scalability etc, you might build low lag high voxel count massively multiplayer games with it, or various experiments somewhere within that.

100% of lambda functions in this system are either quines or part of at least 1 quine. A quine is any loop of such a data format, which in multiverse style branches from each id256 to its next bit being 0 vs 1 to lead to a different possible next n bits that eventually leads back to itself aka a loop of bits of some constant size which is a quine if you start at any id256 in it that leads back to that id256, even if there are for example 53242341 number of id256s in such a loop, and there will be an infinite number of such loops from every id256 back to itself, each of them a quine. The high security of this system, in theory, comes from it being so extremely redundantly cross referenced. The paths between functions are of a distance approx predicted by kolmogorov complexity. For example, from the empty bitstring, the bitstring of the 1 trillionth to 2 trillionth digits of pi should be less than 100 bits from there.

A very simple example of the data format is a few bits, then an id256, then a few more bits to say which path in the 5-way gametree to go, then another 256 bits (so maybe around 520 bits, that is a statement that one id256 (of a lambda function) is the left child (of 2 childs in a binary forest) of another id256/lambda. Another kind of simple example is that any bitstring of size b can be represented in at most b+log2(b)+someSmallConstant number of bits.
